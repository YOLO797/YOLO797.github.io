import{_ as s,W as t,X as o,Y as c,$ as n,a0 as p,Z as i,a1 as e,C as l}from"./framework-b609eea8.js";const d="/assets/reflect-17a6e0f8.jpg",r={},u=e("<ul><li><p><code>vue2</code> 响应式是基于 <code>object.defineProperty</code> 实现的</p></li><li><p><code>vue3</code> 响应式是基于 <code>ES6</code> 的 <code>proxy</code> 配合 <code>Reflect</code> 实现的</p><p>基本数据类型的响应仍是 <code>object.defineProperty</code></p><p>对象类型数据的响应使用 <code>proxy</code></p></li></ul>",1),k={href:"https://juejin.cn/post/7001999813344493581",target:"_blank",rel:"noopener noreferrer"},v=e(`<h3 id="_1-扩展-响应式" tabindex="-1"><a class="header-anchor" href="#_1-扩展-响应式" aria-hidden="true">#</a> 1. 扩展：响应式</h3><ul><li><p>是什么？</p><p>数据响应式就是 能够使数据变化可以被检测并对这种变化做出相应的机制</p></li><li><p>为什么需要响应式？</p><p><code>MVVM</code>核心解决的就是连接数据层和视图层，这样能够在数据发生变化时，立刻做出更新处理</p></li><li><p>有什么好处？</p><p>通过数据响应式加上虚拟<code>DOM</code>和<code>patch</code>算法，开发人员只需要操作数据，提高效率。</p></li></ul><h3 id="_2-track和trigger" tabindex="-1"><a class="header-anchor" href="#_2-track和trigger" aria-hidden="true">#</a> 2. track和trigger</h3><ul><li><p><code>track</code>函数：把所有依赖于 <code>x</code>变量的 <code>effect</code> 函数都收集起来，放在 <code>dep</code>里面</p></li><li><p><code>trigger</code>函数：当 <code>x</code> 变量改变时，执行该函数通知 <code>dep</code> 里面的所有依赖 <code>x</code>变量的 <code>effect</code>函数执行，实现依赖变量的更新</p></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">&#39;tom&#39;</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">18</span>
<span class="token keyword">let</span> myself1 <span class="token operator">=</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span> myself2 <span class="token operator">=</span> <span class="token string">&#39;&#39;</span>
<span class="token keyword">const</span> <span class="token function-variable function">effect1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> myself1 <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">今年</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">岁</span><span class="token template-punctuation string">\`</span></span>
<span class="token keyword">const</span> <span class="token function-variable function">effect2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> myself2 <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">今年居然有</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">岁</span><span class="token template-punctuation string">\`</span></span>

<span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  dep<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effect1<span class="token punctuation">)</span>
  dep<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>effect2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  dep<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effect</span> <span class="token operator">=&gt;</span> <span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-proxy" tabindex="-1"><a class="header-anchor" href="#_3-proxy" aria-hidden="true">#</a> 3. Proxy</h3><h4 id="_3-1-语法" tabindex="-1"><a class="header-anchor" href="#_3-1-语法" aria-hidden="true">#</a> 3.1 语法</h4><p><code>const p = new Proxy(target, handler)</code></p><ul><li><code>target</code>：要使用 <code>proxy</code> 包装的目标对象</li><li><code>handler</code>：通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为</li></ul><h4 id="_3-2-方法" tabindex="-1"><a class="header-anchor" href="#_3-2-方法" aria-hidden="true">#</a> 3.2 方法</h4><ul><li><p><code>has</code>捕获器：<strong><code>has(target, propKey)</code></strong></p><ul><li><code>target</code>：目标对象</li><li><code>propKey</code>：带拦截属性名</li></ul><p>作用：拦截判断 <code>target</code> 对象是否含有属性 <code>propKey</code> 的操作</p><p>对应<code>Reflect</code>：<strong><code>Reflect.has(target, key)</code></strong></p></li><li><p><code>get</code>捕获器：<strong><code>get(target, key, receiver)</code></strong></p><p>访问 <code>target</code> 的 <code>key</code> 属性，但是 <code>this</code> 指向 <code>receiver</code>，所以实际访问的值是 <code>receiver</code> 的 <code>key</code> 值</p><p>返回：返回读取的属性</p><p>作用：拦截对象属性的读取</p><p>对应<code>Reflect</code>：<mark><strong><code>Reflect.get(target, key, receiver)</code></strong></mark></p></li><li><p><code>set</code>捕获器：<strong><code>set(target, key, value, receiver)</code></strong></p><ul><li><code>target</code>：目标对象</li><li><code>propKey</code>：待拦截的属性名</li><li><code>value</code>：新设置的属性值</li><li><code>receiver</code>： <code>proxy</code> 实例</li></ul><p>返回：严格模式下返回 <code>true</code> 操作成功；否则失败报错</p><p>作用：拦截对象的属性赋值操作</p><p>拦截操作：<code>proxy[key] = value</code></p><p>对应<code>Reflect</code>：<mark><strong><code>Reflect.set(obj, key, value, receiver)</code></strong></mark></p></li><li><p><code>ownKeys</code>捕获器</p></li><li><p><code>deleteProperty</code>捕获器</p><p>对应<code>Reflect</code>：<strong><code>Reflect.delete(obj, key)</code></strong></p></li></ul><h4 id="_3-3-实现" tabindex="-1"><a class="header-anchor" href="#_3-3-实现" aria-hidden="true">#</a> 3.3 实现</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>
	<span class="token comment">// 读取属性时调用</span>
  <span class="token function">get</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token comment">//修改属性或添加属性时调用</span>
  <span class="token function">set</span> <span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token comment">//删除属性时调用</span>
  <span class="token function">deleteProperty</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4-reflect" tabindex="-1"><a class="header-anchor" href="#_4-reflect" aria-hidden="true">#</a> 4. Reflect</h3><ul><li><code>Reflect.get(target, key, receiver)</code>：访问 <code>target</code> 的 <code>key</code> 属性，但是 <code>this</code> 是指向 <code>receiver</code>，所以实际访问的值是 <code>receiver</code> 中的 <code>key</code> 的值。但不是直接访问 <code>receiver[key]</code> 属性，会导致无限循环</li><li><code>Reflect.set(obj, key, value, receiver)</code>：设置 <code>target</code> 的 <code>key</code> 属性为 <code>value</code>，但是 <code>this</code> 是指向 <code>receiver</code>，所以实际设置的是 <code>receiver</code> 中的 <code>key</code> 的值为 <code>value</code>。但不是直接设置 <code>receiver[key] = value</code> ，会导致无限循环</li></ul><p><img src="`+d+'" alt="reflect"></p><h3 id="_5-proxy和reflect一起使用" tabindex="-1"><a class="header-anchor" href="#_5-proxy和reflect一起使用" aria-hidden="true">#</a> 5. Proxy和Reflect一起使用</h3><p><code>Proxy</code>和<code>Reflect</code>的方法都是一一对应的，在 <code>proxy</code>中使用 <code>Reflect</code>提高语义化。</p><h3 id="_6-对比" tabindex="-1"><a class="header-anchor" href="#_6-对比" aria-hidden="true">#</a> 6. 对比</h3><p><code>vue2.0</code> 实现<code>MVVM</code>（数据双向绑定）的原理是通过 <code>Object.defineProperty</code> 来劫持各个<strong>属性</strong>中的<code>setter</code> 和 <code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p><code>vue3.0</code> 实现响应式是通过<code>ES6</code>中的<code>Proxy</code>代理目标<strong>对象</strong>，且一开始只代理最外层对象，嵌套对象惰性监听，性能更好。</p><p><strong>vue2响应式：</strong></p><ul><li>基于<code>Object.defineProperty</code>，不具备监听数组的能力，需要重新定义数组的原型才能达到响应式</li><li>数据只有存放在data中才有响应式，或者使用<code>vue.$set</code></li><li>只能劫持对象的属性，每调用一次只能对某一个属性进行劫持，所以需要循环遍历，比较麻烦</li></ul><p><strong>vue3响应式：</strong></p><ul><li>基于<code>Proxy</code> 和 <code>Reflect</code>，可以监听原生数组，可以监听对象属性的添加和删除</li><li>不需要一次性遍历<code>data</code>的属性，可以提高性能</li><li><code>Proxy</code>一开始只代理最外层对象，之后通过判断当前 <code>Reflect.get</code> 的返回值是否为 <code>Object</code>，如果是 则再通过 <code>reactive</code> 方法做代理，实现深度监听</li></ul>',25);function g(f,m){const a=l("ExternalLinkIcon");return t(),o("div",null,[u,c(" more "),n("p",null,[n("a",k,[p("响应式原理"),i(a)])]),v])}const y=s(r,[["render",g],["__file","响应式原理.html.vue"]]);export{y as default};
