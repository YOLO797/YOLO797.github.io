import{_ as s,W as r,X as p,Y as h,Z as n,a2 as i,$ as e,a1 as t,C as u,a0 as l}from"./framework-b609eea8.js";const _="/assets/强缓存和协商缓存-045f2e04.png",g="/assets/TCP-IP四层模型-43754662.png",f="/assets/TCP-IP七层模型-232c3dff.gif",k="/assets/三系握手-79079635.png",m="/assets/四次挥手-af6b3809.png",S={},T=e("p",null,"http、https、tcp/ip等",-1),x=t('<h2 id="_1-http与https" tabindex="-1"><a class="header-anchor" href="#_1-http与https" aria-hidden="true">#</a> 1. HTTP与HTTPS</h2><h3 id="_1-1-区别" tabindex="-1"><a class="header-anchor" href="#_1-1-区别" aria-hidden="true">#</a> 1.1 区别</h3><div class="hint-container info"><p class="hint-container-title">参考答案</p><ul><li><code>https</code> 是 <code>http</code> 协议的安全版本，<code>http</code> 协议的数据传输是明文的，是不安全的， <code>https</code> 使用了 <code>SSL/TLS</code> 协议进行加密处理，<mark>相对安全</mark></li><li><code>http</code> 和 <code>https</code> 使用连接方式不同，默认<mark>端口号不同</mark> ， <code>http</code> 是 80，<code>https</code> 是443</li><li><code>https</code> 需要<mark>多次加密及多次握手</mark>，性能不如 <code>http</code></li><li><code>https</code> 需要 <code>SSL</code>证书，是需要钱的</li></ul></div><h3 id="_1-2-https如何保证安全" tabindex="-1"><a class="header-anchor" href="#_1-2-https如何保证安全" aria-hidden="true">#</a> 1.2 HTTPS如何保证安全</h3><p><code>HTTPS = HTTP+ TLS/SSL</code> 采用 <code>SSL</code> 证书进行加密</p><p><code>SSL</code> 的实现主要依赖于三种手段：</p><ul><li><p>对称加密：采用协商的密钥对数据加密</p><p>加密和解密的密钥使用的都是同一个，是对称的。</p></li><li><p>非对称加密：实现身份认证和密钥协商</p><p>存在两个密钥，一个公钥，一个私钥。公钥可以公开给任何人使用，私钥则需要保密</p><p>公钥加密后只能用私钥解密，私钥加密后只能公钥解密</p></li><li><p>摘要算法：验证信息的完整性</p><p>特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”</p></li><li><p>数字签名：身份验证</p><p>能够确定消息是由发送方签名并发出的，因为别人假冒不了发送方的签名</p><p>就是用私钥加密，公钥解密</p></li></ul><h3 id="_1-3-http1-0-1-1-2-0" tabindex="-1"><a class="header-anchor" href="#_1-3-http1-0-1-1-2-0" aria-hidden="true">#</a> 1.3 HTTP1.0/1.1/2.0</h3>',8),v=e("ul",null,[e("li",null,[l("浏览器和服务器只保持 "),e("mark",null,"短暂的连接"),l("，浏览器每次请求都需要与服务器建立一个 "),e("code",null,"TCP"),l(" 连接")])],-1),P=e("ul",null,[e("li",null,[e("mark",null,"长连接"),l("，即 "),e("code",null,"TCP"),l(" 连接默认不关闭，可以被多个请求复用")]),e("li",null,[l("在同一个 "),e("code",null,"TCP"),l(" 连接中，客户端可以同时发送多个请求（至多6个）")]),e("li",null,[l("所有数据通信是 "),e("mark",null,"按顺序执行"),l(" 的，服务器只有处理完一个请求，才会处理下一个请求")]),e("li",null,[l("新增一些请求方法： "),e("code",null,"put"),l("、"),e("code",null,"delete"),l("、"),e("code",null,"option"),l("等")]),e("li",null,[l("新增一些请求头和响应头： "),e("ul",null,[e("li",null,[l("引入更多的缓存控制策略："),e("code",null,"if-Match"),l(" 、"),e("code",null,"if-None-Match")]),e("li",null,[l("引入 "),e("code",null,"rang"),l("，允许值请求资源某个部分")]),e("li",null,[l("引入 "),e("code",null,"host"),l("，实现了在一台服务器上可以在同一个 "),e("code",null,"IP "),l(" 地址和端口号上使用不同的主机名来创建多个虚拟 "),e("code",null,"WEB"),l(" 站点")])])])],-1),C=e("ul",null,[e("li",null,[l("实现 "),e("mark",null,"多路复用"),l(" ，而非有序并阻塞的，只需要一个连接就可以实现 "),e("mark",null,"并行")]),e("li",null,[l("采用 "),e("mark",null,"二进制格式传输"),l(" 数据而非文本格式")]),e("li",null,[l("使用"),e("mark",null,"报头压缩"),l("，节省开销")]),e("li",null,[e("mark",null,"服务器推送"),l("，允许服务端推送资源给客户端")])],-1),b=t('<p><strong>为什么 HTTP1.1 不能实现多路复用?</strong></p><div class="hint-container info"><p class="hint-container-title">参考答案</p><p>HTTP1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收响应后，并不能区分多个响应对应的请求，所以无法将多个响应的结果重新进行组装，因此不能实现多路复用。</p></div><h3 id="_1-4-http常见状态码" tabindex="-1"><a class="header-anchor" href="#_1-4-http常见状态码" aria-hidden="true">#</a> 1.4 HTTP常见状态码</h3><p>状态码第一位数字决定不同响应状态：</p><ul><li>1 表示消息</li><li>2 表示成功</li><li>3 表示重定向</li><li>4 表示请求错误</li><li>5 表示服务器错误</li></ul><h4 id="_1xx" tabindex="-1"><a class="header-anchor" href="#_1xx" aria-hidden="true">#</a> 1xx</h4><p>表示请求已经被接受，需要继续处理</p><ul><li><strong>100（临时响应）</strong>：用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送剩余部分的请求，如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li><li>101：根据客户端请求切换协议，用于 <code>websocket/http2</code></li></ul><h4 id="_2xx" tabindex="-1"><a class="header-anchor" href="#_2xx" aria-hidden="true">#</a> 2xx</h4><p>代表请求已成功被服务器接收、理解、并接受</p><ul><li>200（成功）：</li><li>201（已创建）：请求成功并且服务器创建了新的资源</li><li>202 （已创建）：请求成功，尚未处理</li><li>203（非授权信息）：已成功处理请求，但返回的信息可能来自另一资源</li><li>204（无内容）</li><li><strong>206（部分内容）</strong>：服务器成功处理了部分请求，断点续传</li></ul><h4 id="_3xx" tabindex="-1"><a class="header-anchor" href="#_3xx" aria-hidden="true">#</a> 3xx</h4><p>表示要完成请求，需要进一步操作，<strong>重定向</strong></p><ul><li><strong>301（永久重定向）</strong>：请求的网页已永久移动到新位置，对 <code>get/head</code>请求的响应自动跳转到新位置</li><li><strong>302（临时重定向）</strong></li><li><strong>304（协商缓存）</strong>：告诉客户端有缓存，直接用缓存中的数据，返回页面的只有头部信息，没有内容部分</li><li>305（使用代理）：通过代理访问请求的网页</li><li>307（临时重定向）</li></ul><h4 id="_4xx" tabindex="-1"><a class="header-anchor" href="#_4xx" aria-hidden="true">#</a> 4xx</h4><p>表示客户端看起来可能发生了错误</p><ul><li><strong>400（错误请求）</strong>：语法错误</li><li>401（未授权）：请求要求身份认证，如登录页</li><li><strong>403（禁止）</strong>：服务器拒绝请求</li><li><strong>404（未找到）</strong></li><li>405（方法禁用）</li><li>406（不接受）：无法使用请求的内容响应请求的网页</li><li>407（需要代理授权）</li><li>408（请求超时）</li></ul><h4 id="_5xx" tabindex="-1"><a class="header-anchor" href="#_5xx" aria-hidden="true">#</a> 5xx</h4><p>表示服务器在处理请求的过程中有错误或者异常状态发生</p><ul><li>500（服务器内部错误）</li><li>502（错误网关）</li><li><strong>503（服务器不可用）</strong>：停机维护时可用</li><li><strong>504（网关超时）</strong></li><li>505（HTTP版本不支持）</li></ul><h2 id="_2-强缓存和协商缓存" tabindex="-1"><a class="header-anchor" href="#_2-强缓存和协商缓存" aria-hidden="true">#</a> 2. 强缓存和协商缓存</h2><p><code>http</code> 缓存机制主要在 <code>http</code> 响应头中设定，<code>Expires</code>、<code>Cache-Control</code>、<code>Last-Modified</code>、<code>Etag</code></p><h3 id="_2-1-强缓存" tabindex="-1"><a class="header-anchor" href="#_2-1-强缓存" aria-hidden="true">#</a> 2.1 强缓存</h3><p><strong>浏览器不会像服务器发送任何请求</strong>，直接从本地缓存中读取并返回200状态码</p><p><strong><code>header</code> 参数</strong>：</p><ul><li><code>Expires</code>：过期时间，浏览器会在设置的时间内直接读取缓存，不再请求</li><li><code>Cache-Control</code>： <ul><li><code>max-age</code>：设置强制缓存时间</li><li><code>public</code>：响应可以被任何缓存区缓存，CDN可以缓存</li><li><code>private</code>：只针对个人用户，不能被代理服务器缓存</li><li><code>no-cache</code>：协商缓存</li><li><code>no-store</code>：禁止缓存，直接拉去最新的资源</li></ul></li></ul><h3 id="_2-2-协商缓存" tabindex="-1"><a class="header-anchor" href="#_2-2-协商缓存" aria-hidden="true">#</a> 2.2 协商缓存</h3><p>向服务器发送请求，服务器会根据这个请求的 <code>header</code> 的一些参数来判断是否命中协商缓存</p><p><strong><code>header</code> 参数</strong>：</p><ul><li><mark><code>Etag/if-None-Match</code></mark><ul><li><code>Etag</code>：</li><li><code>if-None-Match</code>： <ul><li>当资源过期时，有 <code>Etag</code>, 则再次请求时带上请求头 <code>if-None-Match</code>，</li><li>和服务器进行比对</li><li>对比后不同，返回200（请求响应，协商缓存），对比相同返回304（从缓存中读取）</li></ul></li></ul></li><li><mark><code>Last-Modified/if-Modified-Since</code></mark><ul><li><code>Last-Modified</code>：浏览器向服务器发送资源最后修改的时间</li><li><code>if-Modified-Since</code>： <ul><li>当资源过期时，有 <code>Last-Modified</code> ，则再次请求时带上请求头 <code>if-Modified-Since</code> ，表示请求时间。</li><li>服务器收到请求后 对比 <code>Last-Modified</code>和 <code>if-Modified-Since</code></li><li><code>Last-Modified</code> &gt; <code>if-Modified-Since</code>，返回最新资源，<code>HTTP 200 OK</code></li><li><code>Last-Modified </code> &lt; <code>if-Modified-Since</code>，走缓存，<code>HTTP 304</code></li></ul></li></ul></li></ul><div class="hint-container note"><p class="hint-container-title">注</p><ul><li><code>Last-Modified/if-Modified-Since</code> 的时间精度是秒，而 <code>Etag</code> 更精确</li><li><code>Etag</code> 优先级高于 <code>Last-Modified/if-Modified-Since</code></li><li><code>Last-Modified/if-Modified-Since</code> 是 <code>http1.0</code> 的头字段</li></ul></div><p>强制缓存与协商缓存的流程图如下所示：</p><p><img src="'+_+'" alt="强缓存和协商缓存"></p><h2 id="_3-网络七层模型" tabindex="-1"><a class="header-anchor" href="#_3-网络七层模型" aria-hidden="true">#</a> 3. 网络七层模型</h2><h3 id="_3-1-tcp-ip四层模型" tabindex="-1"><a class="header-anchor" href="#_3-1-tcp-ip四层模型" aria-hidden="true">#</a> 3.1 <code>TCP/IP</code>四层模型</h3><p><img src="'+g+'" alt=""></p><h3 id="_3-2-tcp-ip七层模型" tabindex="-1"><a class="header-anchor" href="#_3-2-tcp-ip七层模型" aria-hidden="true">#</a> 3.2 <code>TCP/IP</code>七层模型</h3><p><img src="'+f+'" alt="TCP-IP七层模型"></p><ul><li>物理层：实现计算机节点之间比特流的透明传送，点对点</li><li>数据链路层：使用各种协议传送</li><li>网络层（IP层）：通过源IP地址和目的IP地址进行连接</li><li>数据传输层：主要通过 <code>TCP</code>（可靠） 和 <code>UDP</code>（不可靠）传输数据，可以携带 <code>data</code>、<code>headers</code>、<code>body</code>等数据</li><li>会话层</li><li>表示层</li><li>应用层：<code>HTTP</code>、<code>FTP</code>、<code>SMTP</code>协议等</li></ul><h3 id="_3-3-udp-和-tcp" tabindex="-1"><a class="header-anchor" href="#_3-3-udp-和-tcp" aria-hidden="true">#</a> 3.3 <code>UDP</code> 和 <code>TCP</code></h3>',40),A=e("p",null,[e("mark",null,"不可靠")],-1),M=e("ul",null,[e("li",null,[l("传输途中出现丢包， "),e("code",null,"UDP"),l(" 也不负责重发")]),e("li",null,[l("不提供复杂的控制机制，利用 "),e("code",null,"IP"),l(" 提供无连接的通信服务")]),e("li",null,"传递包时会出现顺序乱的问题"),e("li",null,"无法进行流量控制等避免网络阻塞的行为")],-1),I=e("p",null,[e("mark",null,"可靠")],-1),N=e("ul",null,[e("li",null,"向服务器发送数据时会通知是否成功"),e("li",null,"充分实现了数据传输时的各种控制功能，可以进行丢包时的重发控制，对次序乱掉的分包进行顺序控制")],-1),L=t(`<h2 id="_4-三次握手和四次挥手" tabindex="-1"><a class="header-anchor" href="#_4-三次握手和四次挥手" aria-hidden="true">#</a> 4. 三次握手和四次挥手</h2><h3 id="_4-1-tcp-协议" tabindex="-1"><a class="header-anchor" href="#_4-1-tcp-协议" aria-hidden="true">#</a> 4.1 <code>TCP</code> 协议</h3><p>即传输控制协议。是一种面向连接、可靠的数据传输协议。</p><p><strong>面向连接</strong>：数据传输之前客户端和服务端必须建立连接</p><p><strong>可靠</strong>：数据传输是有序的，要对数据进行校验</p><h3 id="_4-2-tcp-包首部" tabindex="-1"><a class="header-anchor" href="#_4-2-tcp-包首部" aria-hidden="true">#</a> 4.2 <code>TCP</code> 包首部</h3><ul><li><p><code>TCP</code> 端口号</p><p><code>TCP</code> 连接需要：（源 <code>IP</code> ，源端口号）+ （目的 <code>IP</code> ，目的端口号）</p><p>端口号范围 1024 - 65535</p></li><li><p><code>TCP</code> 序列号和确认号</p><ul><li><mark><strong><code>seq</code></strong></mark> ：序列号，用来确认发送的数据<strong>有序</strong></li><li><mark><strong><code>ack</code></strong></mark>：确认号，对上一次 <code>seq</code> 序号做出的确认号，用来响应 <code>TCP</code> 报文段，给收到的报文段的序号== <strong><code>seq+1</code></strong>==</li></ul></li><li><p><code>TCP</code> 标志位</p><ul><li><mark><strong><code>SYN</code></strong></mark>：同步标志位，建立会话连接，<mark>同步序列号</mark></li><li><mark><strong><code>ACK</code></strong></mark>：确认标志位，对已接收的数据包进行<mark>确认</mark></li><li><mark><strong><code>FIN</code></strong></mark>：完成标志位，表示已经没有数据发送了，即将<mark>关闭连接</mark></li></ul></li></ul><h3 id="_4-3-三次握手" tabindex="-1"><a class="header-anchor" href="#_4-3-三次握手" aria-hidden="true">#</a> 4.3 三次握手</h3><p>定义：指建立一个 <code>TCP</code> 连接树，需要客户端和服务器端总共发送<strong>3个报文</strong>。</p><p>目的：确认双方（客户端和服务端）的接收和发送能力是否正常。</p><p>示例：王和陈打电话：</p><pre><code>王：你好，陈，听的到吗？
陈：听到了，王，你能听到吗？
王：听到了，今天一起吃饭？
</code></pre><p><strong>三次握手步骤：</strong></p><p><img src="`+k+`" alt=""></p><ol><li>客户端 --&gt; 服务端：<code>SYN = 1, seq= x</code> ，客户端此时处于 <code>SYN_RCVD</code> <mark>同步已发送</mark> 状态</li><li>服务端 --&gt; 客户端：<code>ACK = 1, SYN = 1, ack = x+1, seq = y</code>，服务端此时处于 <code>SYN_RCVD</code> <mark>同步已接收</mark> 状态</li><li>客户端 --&gt; 服务端：<code>ACK = 1, ack = y+1, seq = x+1</code> ，客户端和服务器端进入<code>ESTABLISHED</code> <mark>已连接</mark> 状态</li></ol><p><strong>为什么要进行三次握手？</strong></p><div class="hint-container info"><p class="hint-container-title">参考答案</p><p>主要原因：<strong>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</strong></p><ul><li>第一次握手：客户端向服务端发送报文，证明客户端发送能力正常</li><li>第二次握手：服务端接收报文并向客户端发送报文，证明服务端接收能力、发送能力正常</li><li>第三次握手：客户端向服务端发送报文，证明客户端接收能力正常</li></ul></div><h3 id="_4-4-四次挥手" tabindex="-1"><a class="header-anchor" href="#_4-4-四次挥手" aria-hidden="true">#</a> 4.4 四次挥手</h3><p>示例: 王和陈对话：</p><pre><code>王：好的，那我先走了
陈：好的，那你走吧
陈：那我也走了？
王：好的，你走吧
</code></pre><p><strong>四次挥手步骤：</strong></p><p><img src="`+m+'" alt=""></p><p>假如客户端先发送关闭请求：</p><ol><li>客户端 --&gt; 服务端：<code>FIN = 1, seq = u</code>（u 为前面已经传送过来的数据最后一个字节的序号+1），客户端此时处于 <code>FIN-WAIT-1</code> <mark>终止等待1</mark> 状态</li><li>服务端 --&gt; 客户端：<code>ACK = 1, ack = u+1, seq = v</code>，服务端此时处于 <code>CLOSE-WAIT</code> <mark>关闭等待</mark> 状态</li><li>服务端 --&gt; 客户端：<code>FIN = 1, ACK = 1, ack = u+1, seq = w</code>，服务器此时进入 <code>LAST-ACK</code> <mark>最后确认</mark> 状态</li><li>客户端 --&gt; 服务端：<code>ACK = 1, ack = w+1, seq = u+1</code>，客户端进入 <code>TIME-WAIT</code> <mark>时间等待</mark> 状态，但此时 <code>TCP</code>连接还未终止，必须要经过 <code>2MSL</code>（最长报文寿命），客户端才进入 <code>CLOSED</code>状态</li></ol><p><strong>挥手为什么需要四次？</strong></p><div class="hint-container info"><p class="hint-container-title">参考答案</p><p>​ 因为当服务器收到客户端的 <code>SYN</code> 连接请求报文后，可直接发送 <code>SYN + ACK</code>报文。<code>ACK</code>报文用来应答， <code>SYN</code> 报文用来同步。</p><p>​ 但是关闭连接时，当服务端收到 <code>FIN</code> 报文时，很可能<mark>不会立即关闭 <code>SOCKET</code> ，所以只能先回复 <code>ACK</code> 报文</mark>，告诉客户端，“你发的 <code>FIN</code> 报文我收到了”。<mark>只有等到服务器所有的报文都发送完了，服务器才会发送 <code>FIN</code>报文，因此不能一起发送</mark>，故需要四次挥手。</p></div><p><strong>四次挥手释放连接时，等待 <code>2MSL</code> 的意义？</strong></p><div class="hint-container info"><p class="hint-container-title">参考答案</p><ul><li><p>保证客户端发送的最后一个 <code>ACK</code> 报文能够到达服务器</p></li><li><p>防止已失效的连接请求报文文段出现在本连接中</p><p>客户端在发送完最后一个ACK报文段后，在经过 <code>2MSL</code>，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p></li></ul></div><p><strong>为什么 <code>TIME_WAIT</code> 状态要等待 <code>2MSL</code>才能返回到 <code>CLOSE</code>状态？</strong></p><div class="hint-container info"><p class="hint-container-title">参考答案</p><p>理论上，四个报文都发送完毕，就可以直接进入 <code>CLOSE</code> 状态，但是可能网络不是可靠的，有可能最后一个 <code>ACK</code>丢失，所以 <code>TIME_WAIT</code>就是用来重发可能丢失的 <code>ACK</code>报文。</p></div><h2 id="_5-get和post区别" tabindex="-1"><a class="header-anchor" href="#_5-get和post区别" aria-hidden="true">#</a> 5. GET和POST区别</h2>',31),E=e("ul",null,[e("li",null,[l("拼接 "),e("code",null,"url")]),e("li",null,"限制字符串长度"),e("li",null,"有缓存")],-1),H=e("ul",null,[e("li",null,[l("数据在 "),e("code",null,"body"),l(" 中传递")]),e("li",null,"没有缓存"),e("li",null,[l("相对 "),e("code",null,"get"),l(" 更安全")])],-1),K=t('<div class="hint-container info"><p class="hint-container-title">参考答案</p><ul><li>浏览器在发送 <code>get</code> 请求时，不会携带请求体</li><li><code>get</code> 适合传少量数据，<code>post</code>没有限制</li><li>大部分 <code>get</code> 请求是在 <code>path</code>参数中，会暴露数据</li><li>刷新页面时，若当前页面是 <code>get</code>请求，则没有提示，<code>post</code>会提示用否是否重新提交</li><li><code>get</code>请求的地址会被保存为浏览器书签</li></ul></div><h2 id="_6-cdn" tabindex="-1"><a class="header-anchor" href="#_6-cdn" aria-hidden="true">#</a> 6. CDN</h2><h2 id="_7-从输入url到获取页面完整过程" tabindex="-1"><a class="header-anchor" href="#_7-从输入url到获取页面完整过程" aria-hidden="true">#</a> 7. 从输入URL到获取页面完整过程</h2><div class="hint-container info"><p class="hint-container-title">参考答案</p><ol><li>判断是否有缓存，有缓存直接返回，没有则进行下一步</li><li><code>DNS</code>解析，获取源 <code>IP</code> 地址和目标 <code>IP</code>地址</li><li>进行 <code>TCP</code>连接 ，三次握手</li><li>发送 <code>http</code> 请求，服务端根据请求响应数据</li><li>渲染页面，构建 <code>DOM</code> 树</li><li>关闭 <code>TCP</code> 连接</li></ol></div><h2 id="_8-cookie、localstroage、sessionstroage" tabindex="-1"><a class="header-anchor" href="#_8-cookie、localstroage、sessionstroage" aria-hidden="true">#</a> 8. cookie、localStroage、sessionStroage</h2>',5),D=e("ul",null,[e("li",null,"大小：4kb"),e("li",null,"可设置失效时间"),e("li",null,"请求携带在 http")],-1),q=e("ul",null,[e("li",null,"大小无限制"),e("li",null,"除非手动删除，否则永久有效"),e("li",null,"客户端缓存"),e("li",null,"不参与和服务器的通信")],-1),O=e("ul",null,[e("li",null,"大小无限制"),e("li",null,"当前会话下有效"),e("li",null,"客户端保存"),e("li",null,"不参与和服务器通讯")],-1),y=t('<div class="hint-container info"><p class="hint-container-title">参考答案</p><ul><li>存储大小：<code>cookie</code>：4k，<code>sessionStroage</code>、<code>localStroage</code>：5M或更大</li><li>有效时间：<code>cookie</code>：设置的过期时间内有效，<code>sessionStroage</code>在当前会话内有效，<code>localStroage</code> 除非手动删除，否则永久有效</li><li>数据与服务器之间的交互方式：<code>cookie</code>的数据会自动传递到服务器，<code>sessionStroage</code>和<code>localStroage</code> 仅本地保存，不会发给服务器</li></ul></div><h2 id="_9-csr、ssr、ssg" tabindex="-1"><a class="header-anchor" href="#_9-csr、ssr、ssg" aria-hidden="true">#</a> 9. CSR、SSR、SSG</h2>',2),Y=e("p",null,"客户端渲染",-1),F=e("p",null,"优点：",-1),R=e("ul",null,[e("li",null,"前后端分离"),e("li",null,"服务器压力变轻"),e("li",null,[l("用户在后期访问操作体验好，（首屏喧染慢）可以将网站做成 "),e("code",null,"SPA"),l("，可以增量渲染")])],-1),V=e("p",null,"缺点：",-1),W=e("ul",null,[e("li",null,"首屏渲染时间过长，不利于首屏渲染"),e("li",null,[l("不利于 "),e("code",null,"SEO"),l("，因为搜索引擎不执行相关 "),e("code",null,"JS"),l("操作，无法获取选然后的最终 "),e("code",null,"html")])],-1),w=e("p",null,"服务端渲染",-1),B=e("p",null,"优点：",-1),U=e("ul",null,[e("li",null,[l("有利于 "),e("code",null,"SEO")]),e("li",null,"有利于首屏渲染，首屏渲染时间变短")],-1),j=e("p",null,"缺点：",-1),J=e("ul",null,[e("li",null,"占用服务端资源，渲染工作都在服务端渲染"),e("li",null,"用户体验不好，每次跳转到新页面都需要服务器重新渲染整个页面，不能只渲染可变区域")],-1),G=e("p",null,"静态资源生成，一般用于博客搭建",-1),X=e("p",null,"缺点：",-1),Z=e("ul",null,[e("li",null,"只适用于静态资源")],-1),$=t(`<h2 id="_10-跨域" tabindex="-1"><a class="header-anchor" href="#_10-跨域" aria-hidden="true">#</a> 10. 跨域</h2><div class="hint-container info"><p class="hint-container-title">参考答案</p><ol><li><p>代理 <code>proxy</code></p></li><li><p><code>cros</code></p><p>在请求时，客户端使用一些特殊的请求头向服务器申请跨域访问，并通过这些请求头告诉服务器自己的行为。服务器根据自身的规则决定是否允许跨域，如果允许，则通过响应头告诉客户端可以发送跨域请求。</p></li><li><p><code>JSONP</code>（只支持 <code>get</code> 请求）</p><ol><li><p>事先准备一个处理服务器数据的全局函数，用来接收数据</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>创建一个 <code>sript</code> 标签，<code>src</code> 指向跨域站点，同时把准备好的函数名通过地址参数传递到服务器</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">&quot;</span>......./callback=func<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>客户端通过 <code>src</code> 向服务端发送请求，服务端接收并响应数据 <code>data</code></p></li><li><p><code>func(&#39;+JSON.stringify(data)&#39;)</code> 以参数的形式返回，运行 <code>func</code> 函数</p></li></ol></li></ol></div><h2 id="_11-优化网络性能" tabindex="-1"><a class="header-anchor" href="#_11-优化网络性能" aria-hidden="true">#</a> 11. 优化网络性能</h2><div class="hint-container info"><p class="hint-container-title">参考答案</p><ol><li><p>优化打包体积</p></li><li><p>压缩</p></li><li><p>缓存</p></li><li><p>CDN</p></li><li><p>http2</p><p>开启多路复用、头部压缩等特点，充分利用带宽传递大量文件数据</p></li><li><p>雪碧图</p></li><li><p>defer、async</p><p>通过 <code>defer</code>、<code>async</code> 属性，可以让页面尽早加载 <code>js</code>文件</p><ul><li><p><code>defer</code>：<strong>渲染完在执行</strong>。要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行</p></li><li><p><code>async</code>：<strong>下载完就执行</strong>。一旦下载完成，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染</p></li></ul></li><li><p>prefetch、preload</p><p><code>preload</code>：对于当前页面很有必要的资源。尽早加载首屏的关键资源，提升页面渲染性能。一些隐藏在 CSS、JS中的资源（字体文件）</p><p><code>preload</code>：对于可能在将来的页面中使用的资源，异步加载模块</p></li></ol></div>`,4);function z(Q,ee){const a=u("Tabs");return r(),p("div",null,[T,h(" more "),x,n(a,{id:"86",data:[{title:"HTTP1.0"},{title:"HTTP1.1"},{title:"HTTP2.0"}]},{tab0:i(({title:o,value:d,isActive:c})=>[v]),tab1:i(({title:o,value:d,isActive:c})=>[P]),tab2:i(({title:o,value:d,isActive:c})=>[C]),_:1},8,["data"]),b,n(a,{id:"596",data:[{title:"UDP"},{title:"TCP"}],active:1},{tab0:i(({title:o,value:d,isActive:c})=>[A,M]),tab1:i(({title:o,value:d,isActive:c})=>[I,N]),_:1}),L,n(a,{id:"853",data:[{title:"get"},{title:"post"}]},{tab0:i(({title:o,value:d,isActive:c})=>[E]),tab1:i(({title:o,value:d,isActive:c})=>[H]),_:1}),K,n(a,{id:"965",data:[{title:"Cookie"},{title:"LocalStroage"},{title:"SessionStroage"}]},{tab0:i(({title:o,value:d,isActive:c})=>[D]),tab1:i(({title:o,value:d,isActive:c})=>[q]),tab2:i(({title:o,value:d,isActive:c})=>[O]),_:1}),y,n(a,{id:"1056",data:[{title:"CSR"},{title:"SSR"},{title:"SSG"}]},{tab0:i(({title:o,value:d,isActive:c})=>[Y,F,R,V,W]),tab1:i(({title:o,value:d,isActive:c})=>[w,B,U,j,J]),tab2:i(({title:o,value:d,isActive:c})=>[G,X,Z]),_:1}),$])}const ie=s(S,[["render",z],["__file","HTTP.html.vue"]]);export{ie as default};
