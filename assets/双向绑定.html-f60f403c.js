import{_ as d,W as c,X as i,Y as l,$ as e,a0 as o,a1 as t}from"./framework-b609eea8.js";const a="/assets/vue2.0双向绑定-f629fb62.png",r={},n=e("p",null,[o("vue2.0双向绑定原理 使用 "),e("code",null,"MVVM"),o(" 架构，只需关注业务层逻辑，不需要手动操作 "),e("code",null,"DOM")],-1),p=t('<h3 id="_1-什么是双向绑定" tabindex="-1"><a class="header-anchor" href="#_1-什么是双向绑定" aria-hidden="true">#</a> 1. 什么是双向绑定</h3><p>用户更新了 <code>View</code>，<code>Model</code>也自动更新</p><h3 id="_2-双向绑定部分组成" tabindex="-1"><a class="header-anchor" href="#_2-双向绑定部分组成" aria-hidden="true">#</a> 2. 双向绑定部分组成</h3><p>双向绑定由三个重要部分组成：</p><ul><li>数据层（<code>Model</code>）：应用的数据及业务逻辑</li><li>视图层（<code>View</code>）：应用的展示效果，各类 <code>UI</code>组件</li><li>业务逻辑层（<code>ViewModel</code>）：框架封装的核心，负责将视图和数据连接起来</li></ul><p><code>ViewModel</code> 的主要职责：</p><ul><li>数据变化更新视图</li><li>视图变化更新数据</li></ul><p><code>ViewModel</code> 的两个主要组成部分：</p><ul><li>监听器（<code>Observer</code>）：对所有数据的属性进行监听</li><li>解析器（<code>Compiler</code>）：对每个元素节点的指令进行扫描跟解析，根据指令模板替换数据以及绑定相应的更新函数</li></ul><h3 id="_3-双向绑定原理" tabindex="-1"><a class="header-anchor" href="#_3-双向绑定原理" aria-hidden="true">#</a> 3. 双向绑定原理</h3><p>两个阶段：</p><ul><li>初始化阶段：数据监听、页面渲染</li><li>数据更新阶段</li></ul><div class="hint-container info"><p class="hint-container-title">参考答案</p><ul><li><p><code>Vue2.0</code> 采用数据劫持结合发布订阅模式的方式，通过 <code>Object.defineProperty</code> 来劫持各个属性的 <code>getter</code> 、<code>setter</code>，在数据变动时发布消息给订阅者 <code>Watcher</code> ，触发相应的监听回调。</p></li><li><p>当把一个普通的 <code>javascript</code> 对象传给 <code>Vue</code> 实例来作为它的 <code>data</code> 选项时， <code>Vue</code> 将遍历它的属性，通过 <code>Object.defineProperty</code> 将它们转化为 <code>getter/setter</code> 进行数据监听。</p></li><li><p><code>Vue</code> 的数据双向绑定整合了 <code>Observer</code> 、<code>Compile</code>、<code>Watcher</code> 三者，通过 <code>Observer</code> 来监听自己的 <code>model</code> 的数据变化，通过 <code>Compile</code> 来解析模板指令，最终利用 <code>Watcher</code> 搭起 <code>Observer</code> 和<code>Compile</code>之间的桥梁，达到数据变化 -&gt; 视图更新，视图交互变化 -&gt; 数据 <code>model</code>变更的双向绑定效果。</p></li><li><p>数据 <code>data</code> 变化 --&gt; <code>Observer</code> 中的 <code>setter</code> 触发 <code>Dep.notify()</code> --&gt; <code>Dep</code> 开始遍历所有的订阅者，对 <code>Watcher</code> 发送通知 --&gt; 触发 <code>update()</code> --&gt; <code>Watcher</code> 收到 <code>Dep</code>的通知 --&gt; 相应视图更新</p></li></ul></div><p><strong>流程：</strong></p><ol><li><code>new Vue()</code> 执行初始化，对 <code>data</code> 执行相应化处理，这个过程发生在 <code>Observer</code>中</li><li><code>Compile</code> 对模板进行编译，找到其中动态绑定的数据，从 <code>data</code> 中获取并初始化视图</li><li>同时定义一个更新函数（<code>update</code>）和 <code>Watcher</code>，将来数据变化时 <code>Watcher</code> 会调用更新函数</li><li>由于 <code>data</code> 的某个 <code>key</code> 在一个视图中可能出现多次，所以每个 <code>key</code> 都需要一个管家 <code>Dep</code> 来管理多个 <code>Watcher</code></li><li><code>data</code> 数据变化，首先会找到 对应的<code>Dep</code>，通知所有 <code>Watcher</code>执行更新函数</li></ol><p><img src="'+a+'" alt="vue2.0双向绑定"></p><h3 id="_4-v-model-双向绑定原理" tabindex="-1"><a class="header-anchor" href="#_4-v-model-双向绑定原理" aria-hidden="true">#</a> 4. v-model 双向绑定原理</h3><div class="hint-container info"><p class="hint-container-title">参考答案</p><p><code>v-model</code> 本质就是 <code>value + input</code> 方法的语法糖。可以通过 <code>model</code> 属性的 <code>prop</code> 和 <code>event</code> 属性来进行自定义。原生的 <code>v-model</code>，会根据标签的不同生成不同的事件和属性。</p><ul><li><code>text</code> 和 <code>textarea</code>：<code>value</code> + <code>input()</code></li><li><code>checkbox</code> 和 <code>redio</code>：<code>checked</code> + <code>change()</code></li><li><code>select</code> 将 <code>value</code> 作为 <code>prop</code> ，并将 <code>change</code> 作为事件</li></ul></div><h3 id="_5-问题" tabindex="-1"><a class="header-anchor" href="#_5-问题" aria-hidden="true">#</a> 5. 问题</h3><ul><li><code>object.defineProperty()</code> 不能监听对象的添加和删除，但是可以利用 <code>Vue.set</code> 或者 <code>this.$set</code> 来解决此问题。</li><li><code>object.defineProperty()</code> 无法监听数组下标的变化，导致通过数组下标添加的元素，不能实时响应</li><li><code>object.defineProperty()</code> 只能劫持对象的属性</li></ul>',20);function s(h,u){return c(),i("div",null,[n,l(" more "),p])}const v=d(r,[["render",s],["__file","双向绑定.html.vue"]]);export{v as default};
